//
// Created by marcin on 31/12/18.
//

#ifndef GENETIC_ACTOR_DATA_H
#define GENETIC_ACTOR_DATA_H

#include <any>
#include "../common.hpp"
#include "message_bus.hpp"

namespace cpga {
namespace core {
/**
 * @brief This alias to a map between string and any is dedicated for
 * storage of arbitrary user-defined data (necessary for passing
 * custom arguments to some genetic operators)
 */
using user_properties = std::unordered_map<std::string, std::any>;

/**
 * @brief This struct defines parameters commonly used
 * by the framework.
 */
struct system_properties {
  /**
   * @brief The total size of the population before it is divided among islands.
   * When model == ISLAND, one needs to either set this property and islands_number or population_size
   * directly.
   */
  size_t total_population_size;
  /**
   * @brief The size of the population understood as panmictic pool size by GLOBAL and GRID models.
   */
  size_t population_size;
  /**
   * @brief The size of a sequence individual. Meaningful only when one uses sequence_* genetic operators with
   * sequence individual population pool.
   * @note This setting is likely to be moved to user_properties as it does not describe core system property.
   */
  size_t individual_size;
  /**
   * @brief The a) number of islands in ISLAND model or b) number of workers in GLOBAL and GRID models.
   */
  size_t islands_number;
  /**
   * @brief The maximum number of generations a PGA model will be run for.
   */
  size_t generations_number;
  /**
   * @brief The number of elitists preserved each generation whe is_elitism_active is set.
   */
  size_t elitists_number;
  /**
   * @brief The number of generations which have to be executed until a migration can occur.
   */
  size_t migration_period;
  /**
   * @brief The number of migrants belonging to the migration payload generated by each island during migration phase.
   */
  size_t migration_quota;
  /**
   * @brief Elitism activation flag.
   */
  bool is_elitism_active;
  /**
   * @brief Survival selection activation flag.
   */
  bool is_survival_selection_active;
  /**
   * @brief Migration activation flag.
   */
  bool is_migration_active;
  /**
   * @brief Should possible constituent values of a sequence individual be
   * repeated when constructing such individual in sequence_individual_initialization.
   * @details If set, a vector<int> individual [1,2,3,4,5,1,2] can be constructed with
   * a possible element set of [1,2,3,4,5].
   * @note This setting is likely to be moved to user_properties as it does not describe core system property.
   */
  bool can_repeat_individual_elements;
  /**
   * @brief Should island number (unique to every island) be added to seeds defined in this configuration.
   * The purpose of this setting is to ensure different seed values for each island.
   */
  bool add_island_no_to_seed;
  /**
   * @brief Seed value for initialization operator.
   */
  unsigned long initialization_seed;
  /**
   * @brief Seed value for mutation operator.
   */
  unsigned long mutation_seed;
  /**
   * @brief Seed value for crossover operator.
   */
  unsigned long crossover_seed;
  /**
   * @brief Seed value for parent selection operator.
   */
  unsigned long parent_selection_seed;
  /**
   * @brief Seed value for survival selection operator.
   */
  unsigned long survival_selection_seed;
  /**
   * @brief Seed value for migration operator.
   */
  unsigned long migration_seed;
  /**
   * @brief The probability of crossover
   * @note Custom crossover operators can
   * define their own properties describing this probability and pass them via user_props.
   */
  double crossover_probability;
  /**
   * @brief The probability of mutation
   * @note Custom mutation operators can
   * define their own properties describing this probability and pass them via user_props.
   */
  double mutation_probability;

  /**
   * @brief System reporter activation flag.
   */
  bool is_system_reporter_active;
  /**
   * @brief System reporter log file path.
   */
  std::string system_reporter_log;

  /**
   * @brief Generation reporter activation flag.
   */
  bool is_generation_reporter_active;
  /**
   * @brief Generation reporter log file path.
   */
  std::string generation_reporter_log;

  /**
   * @brief Individual reporter activation flag.
   */
  bool is_individual_reporter_active;
  /**
   * @brief Individual reporter log file path.
   */
  std::string individual_reporter_log;

  /**
   * @brief Intended PGA model of this configuration.
   */
  pga_model model;

  /**
   * @brief Apply model-specific configuration.
   * @details This function primarily computes the island population size
   * for the user. It should be called after all parameters are set.
   */
  inline void compute_population_size() {
    if (model == pga_model::ISLAND) {
      if (total_population_size && islands_number) {
        population_size = total_population_size / islands_number;
      } else if (!population_size) {
        throw std::runtime_error("Either total_population_size != 0 && islands_number != 0 or population_size != 0");
      }
    } else if (model == pga_model::GRID) {
      if (total_population_size) {
        population_size = total_population_size;
      } else {
        throw std::runtime_error("total_population_size > 0 in grid model");
      }
    }
  }

  /**
   * @brief Define this configration for island model.
   */
  inline void island_model() {
    model = pga_model::ISLAND;
  }

  /**
   * @brief Define this configration for grid model.
   */
  inline void grid_model() {
    model = pga_model::GRID;
  }

  /**
   * @brief Define this configration for global model.
   */
  inline void global_model() {
    model = pga_model::GLOBAL;
  }

  /**
   * @brief Define this configration for sequential model.
   */
  inline void sequential_model() {
    model = pga_model::SEQUENTIAL;
  }

  system_properties();
};

/**
 * @brief This struct encapsulates system- and user-specific
 * settings as well as access to certain utilities (reporter actors and
 * message bus).
 */
struct configuration {
  configuration(const system_properties &system_props,
                const user_properties &user_props,
                message_bus &&bus);

  configuration(const system_properties &system_props,
                const user_properties &user_props,
                actor &generation_reporter,
                actor &individual_reporter,
                actor &system_reporter,
                message_bus &&bus);

  /**
   * @brief Core system configuration.
   */
  system_properties system_props;
  /**
   * @brief Additional, user defined system configuration used by custom genetic operators.
   */
  user_properties user_props;


  /**
   * @brief The handle to local or remote generation reporter actor.
   */
  actor generation_reporter;
  /**
   * @brief The handle to local or remote individual reporter actor.
   */
  actor individual_reporter;
  /**
   * @brief The handle to local or remote system reporter actor.
   */
  actor system_reporter;

  /**
   * @brief The local message bus (not intended to be used across the network).
   */
  message_bus bus;
};

/**
 * @brief This shared pointer is the only way configuration can be accessed
 * during model runtime. It needs to be safely published (immutable) to ensure
 * tread safety.
 */
using shared_config = std::shared_ptr<const configuration>;

template<typename... Args>
inline auto make_shared_config(Args &&... args) {
  return std::make_shared<const configuration>(std::forward<Args>(args)...);
}

template<typename A>
inline void show_model_info(A &&self, const system_properties &props) {
  log(self, "** PGA info **");
  log(self, "-- Model: ", strings::PGA_MODEL_MAP[to_underlying(props.model)]);
  log(self, "-- Generations: ", props.generations_number);
  switch (props.model) {
    case pga_model::ISLAND:log(self, "-- Total initial population size: ", props.total_population_size);
      log(self, "-- Islands: ", props.islands_number);
      log(self, "-- Per island initial population size: ", props.population_size);
      log(self, "-- Migration quota: ", props.migration_quota);
      log(self, "-- Migration period: ", props.migration_period, " generations");
      break;
    case pga_model::GRID:log(self, "-- Total initial population size: ", props.population_size);
      log(self, "-- Grid workers: ", props.islands_number);
      break;
    case pga_model::GLOBAL:
    case pga_model::SEQUENTIAL:log(self, "-- Total initial population size: ", props.population_size);
      break;
  }
  std::vector<std::string> reporters;
  if (props.is_generation_reporter_active)
    reporters.push_back("generation reporter (" + props.generation_reporter_log + ")");
  if (props.is_individual_reporter_active)
    reporters.push_back("individual reporter (" + props.individual_reporter_log + ")");
  if (props.is_system_reporter_active)
    reporters.push_back("system reporter (" + props.system_reporter_log + ")");
  log(self, "-- Reporters: ", join(reporters, ", "));
  log(self, "** Starting execution now **");
}
}
}

#endif //GENETIC_ACTOR_DATA_H
